/// \file   order_book.cpp
///
/// \brief
///
/// \authors    Maarten P. Scholl
/// \date       2020-09-04
/// \copyright  Copyright 2017-2020 The Institute for New Economic Thinking,
///             Oxford Martin School, University of Oxford
///
///             Licensed under the Apache License, Version 2.0 (the "License");
///             you may not use this file except in compliance with the License.
///             You may obtain a copy of the License at
///
///                 http://www.apache.org/licenses/LICENSE-2.0
///
///             Unless required by applicable law or agreed to in writing,
///             software distributed under the License is distributed on an "AS
///             IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
///             express or implied. See the License for the specific language
///             governing permissions and limitations under the License.
///
///             You may obtain instructions to fulfill the attribution
///             requirements in CITATION.cff
///


// import the order book
#include <esl/economics/markets/order_book/static_order_book.hpp>

// import currencies, because we will be trading the stock against USD
#include <esl/economics/currencies.hpp>

// we will fix the namespace mess once the API stabilises
using namespace esl;
using namespace esl::economics;
using namespace esl::economics::markets::order_book;
using esl::economics::markets::order_book::limit_order_message;

// trades in this market are in multiples of the lot size
// e.g. a lot_size of 100 means that a buy order for a quantity of 3 buys 300 shares
// A larger lot size enables small tick sizes
constexpr size_t lot_size = 100;

// helper function to create limit orders submitted to an exchange.
// note that ESL uses fixed-precision for prices internally, and that the use of
// a floating point type here relies on the developer understanding the
// conversion.
limit_order_message create(double p, size_t q = 1000, limit_order_message::side_t side = limit_order_message::side_t::sell)
{
    // substitute your own stock ticker type here
    esl::economics::markets::ticker ticker_dummy_;

    // substitute your agent id
    identity<agent> owner_dummy_;

    return limit_order_message
        ( ticker_dummy_
            , owner_dummy_
            , side
            , markets::quote(price(p, currencies::USD), lot_size * currencies::USD.denominator)
            , q
            ,limit_order_message::lifetime_t::good_until_cancelled
        );
}

//
int main(int argc, char** argv) {
    // create the range of valid prices for the order book (inclusive)
    // quote is a generic type which can be a price, interest rate, etc
    auto  min_ = markets::quote(price( 0.01, currencies::USD), lot_size * currencies::USD.denominator);
    auto  max_ = markets::quote(price(10.00, currencies::USD), lot_size * currencies::USD.denominator);

    // define the maximum number of open orders
    // as the static_order_book maintains a fixed-size memory pool
    constexpr size_t max_orders_ = 1'00'000;

    // creates the order book
    auto book_ = static_order_book(min_, max_, 1024*1024);

    book_.insert(create(4.75, 500, limit_order_message::side_t::buy));
    book_.insert(create(4.75, 750, limit_order_message::side_t::sell));

    // use book_.reports to view the output generated by the order book, which contains
    //  1. the placement of the buy order
    //  2. matching 500 of the buy and sell order (confirmed for each agent)
    //  3. placement of the remainder 250 of the sell order
}